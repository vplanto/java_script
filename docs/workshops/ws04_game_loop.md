# Workshop: Game Loop та Алгоритми (Ping Pong)

Ми створили статичну верстку, ми погралися з DOM. Тепер час створити **динамічну систему**, яка живе своїм життям 60 разів на секунду.

Ми розберемо гру Ping Pong, зрозуміємо, як працює ігровий цикл, і перепишемо "мозок" комп'ютера, щоб він став непереможним.

## 1. Анатомія Гри (Game Loop)

Запустіть код з папки `examples/module_02_logic/pong_game`.
Відкрийте `pong.js`. Знайдіть функцію `loop()`:

```javascript
function loop() {
    update(); // 1. Логіка: Математика, колізії, AI
    draw();   // 2. Рендер: Малювання прямокутників на Canvas
    requestAnimationFrame(loop); // 3. Рекурсія: "Браузер, зроби це знову, коли будеш готовий"
}
```

**Інженерний інсайт:**
Чому ми не використовуємо `setInterval(loop, 16)`?
Тому що `requestAnimationFrame` синхронізується з частотою оновлення монітора (Hz). Якщо комп'ютер повільний, браузер сам знизить частоту кадрів, але не "завісить" сторінку. Це стандарт індустрії.

## 2\. Фізика та Колізії

Подивіться на функцію `update()`. Весь рух — це проста арифметика.

```javascript
ball.x += ball.dx; // Зміна позиції по X
ball.y += ball.dy; // Зміна позиції по Y
```

**Collision Detection (Детекція зіткнень):**
Як ми розуміємо, що м'яч вдарився об ракетку?

```javascript
if (ball.x < player.x + player.width && 
    ball.y > player.y && 
    ball.y < player.y + player.height) {
        ball.dx *= -1; // Інверсія вектора швидкості
}
```

Це алгоритм **AABB** (Axis-Aligned Bounding Box). Ми перевіряємо, чи перетинаються два прямокутники.

## 3\. Challenge: Hacking the AI

Знайдіть функцію `updateAI()`. Зараз вона виглядає так:

```javascript
function updateAI(ai, ball) {
    // Якщо м'яч нижче центру ракетки -> рухаємось вниз
    if (ai.y + ai.height / 2 < ball.y) ai.y += ai.dy;
    // Якщо м'яч вище -> рухаємось вгору
    if (ai.y + ai.height / 2 > ball.y) ai.y -= ai.dy;
}
```

Зараз у робота швидкість `dy = 1`, а у м'яча `dy = 2`. Робот повільний. Він програє.

### Рівень 1: "Чесний гравець" (Hard Mode)

Змініть швидкість робота `ai.dy` в об'єкті `ai` з `1` на `2` (або `3`).
Тепер він встигає за м'ячем. Це чесна гра.

### Рівень 2: "God Mode" (Cheating)

Давайте змінимо алгоритм так, щоб робот **миттєво** опинявся там, де м'яч. Ми прибираємо поняття "швидкості" і використовуємо телепортацію.

Змініть функцію `updateAI`:

```javascript
function updateAI(ai, ball) {
    // Центр ракетки завжди дорівнює центру м'яча
    ai.y = ball.y - (ai.height / 2);
}
```

**Результат:** Ви не зможете забити гол. Ніколи. Це ідеальний захист.

### Рівень 3: "Математик" (Prediction)

Телепортація виглядає неприродно. Справжній інженерний підхід — це **передбачення**.
Ми знаємо координати м'яча ($x, y$) і його вектор ($dx, dy$). Ми можемо вирахувати точку, де м'яч перетне лінію воріт робота, ще до того, як він туди долетить.

*Це завдання із зірочкою для тих, хто любить геометрію.*

## 4. Домашнє завдання: "Баг зміщення"

В коді є архітектурна помилка, яку новачки часто не помічають.
Ми керуємо ракеткою так:
```javascript
window.addEventListener('mousemove', function(event) {
    player.y = event.clientY;
});
```

**Експеримент:**
Додайте в `index.html` будь-який текст або заголовок `<h1>Ping Pong</h1>` перед елементом `<canvas>`. Це зсуне ігрове поле вниз.
Тепер спробуйте пограти.
**Що сталося?** Ваша мишка знаходиться в одній точці, а ракетка — значно нижче. Вони розсинхронізувалися.

**Чому?**
`event.clientY` дає координату відносно **вікна браузера**, а `player.y` очікує координату всередині **Canvas**.

**Завдання:**
Виправити розрахунок координат, щоб ракетка завжди була чітко під курсором, незалежно від того, де на сторінці знаходиться Canvas.

**Підказка для інженера:**
Вам потрібно дізнатися позицію Canvas на сторінці (`canvas.getBoundingClientRect()`) і відняти її від координати миші.

## 5. Граничні випадки (Edge Cases): Куди зник м'яч?

Спробуйте спеціально пропустити м'яч повз ракетку.
**Що сталося?** М'яч полетів за межі екрану і зник назавжди. Гру зламано. Вам потрібно перезавантажувати сторінку.

**Чому це погано?**
Це називається "Happy Path Programming" — коли програміст пише код тільки для успішного сценарію (м'яч відбито), і ігнорує негативний (м'яч пропущено).

**Завдання:**
Реалізуйте механіку "Гол". Якщо м'яч вилітає за ліву або праву межу екрану — повертайте його в центр.

Додайте цю логіку в функцію `update()`:

```javascript
// Якщо м'яч вилетів ліворуч (гол роботу) АБО праворуч (гол гравцю)
if (ball.x < 0 || ball.x > canvas.width) {
    // 1. Повернути в центр
    ball.x = canvas.width / 2;
    ball.y = canvas.height / 2;
    
    // 2. Змінити напрямок (щоб летів у бік того, хто пропустив, або навпаки)
    ball.dx *= -1;
    
    // (Опціонально) Тут можна збільшувати лічильник рахунку
}
```